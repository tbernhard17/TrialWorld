// Obsolete: Enhancement features removed.         TrialWorld.Core.Models.EnhancementConfig? _config = null;         MediaInfo? _mediaInfo = null;         bool IsProcessing => _isActive && !_isDisposed;         double CurrentLatency  get;  set;          double MaxLatency  get; set;  = 1000; // Default to 1 second         event EventHandler<EnhancementStats>? StatisticsUpdated = null;         event EventHandler<double>? LatencyExceeded = null;         EnhancementEngine(ILogger<EnhancementEngine> logger, IFFmpegRealTimeService ffmpegService)                    _logger = logger ?? throw new ArgumentNullException(nameof(logger));            _ffmpegService = ffmpegService ?? throw new ArgumentNullException(nameof(ffmpegService));            _monitoringCts = new CancellationTokenSource();                /// <inheritdoc />         async Task<EnhancementResult> ApplyFiltersAsync(            string sourcePath,            string destinationPath,            IEnumerable<MediaFilter> filterStack,            IProgress<EnhancementProgress>? progress = null,            CancellationToken cancellationToken = default)                    if (_isDisposed)                throw new ObjectDisposedException(nameof(EnhancementEngine));            if (string.IsNullOrEmpty(sourcePath))                throw new System.Exception("Source path cannot be null or empty");            if (string.IsNullOrEmpty(destinationPath))                throw new ArgumentException("Destination path cannot be null or empty", nameof(destinationPath));            if (filterStack == null)                throw new ArgumentNullException(nameof(filterStack));            if (!File.Exists(sourcePath))                throw new System.Exception($"Source file not found: sourcePath");            try                            _logger.LogInformation("Enhancing media: Input=InputPath, Output=OutputPath, Filters=Filters", sourcePath, destinationPath, filterStack);                // Ensure output directory exists                string path = Path.GetDirectoryName(destinationPath);                if (path == null) throw new ArgumentNullException(nameof(path));                if (!Directory.Exists(path))                                    if (path == null) throw new ArgumentNullException(nameof(path));Directory.CreateDirectory(path);                                // Build FFmpeg command with filters                string ffmpegCommand = BuildFilterCommand(sourcePath, destinationPath, filterStack);                var stopwatch = Stopwatch.StartNew();                // Start a process to run FFmpeg                using var process = new Process                                    StartInfo = new ProcessStartInfo                                            FileName = "ffmpeg",                        Arguments = ffmpegCommand,                        UseShellExecute = false,                        CreateNoWindow = true,                        RedirectStandardError = true,                        RedirectStandardOutput = true                                    ;                // Create progress reporting handler                var progressHandler = new Progress<string>(line =>                                    if (progress == null) return;                    // Parse FFmpeg progress output and update progress reporter                    if (TryParseProgress(line, out var progressInfo))                                            progress.Report(progressInfo);                                    );                // Start the process                process.Start();                // Wait for process to complete                await process.WaitForExitAsync(cancellationToken);                // Stop timer                stopwatch.Stop();                // Check if process was successful                if (process.ExitCode != 0)                                    string errorOutput = await process.StandardError.ReadToEndAsync(cancellationToken);                    _logger.LogError("FFmpeg process failed with exit code ExitCode: Error",                        process.ExitCode, errorOutput);                    return new EnhancementResult                                            IsSuccess = false,                        OutputFilePath = destinationPath,                        ProcessingTime = stopwatch.Elapsed,                        ErrorMessage = $"FFmpeg failed with exit code process.ExitCode: errorOutput",                        CommandUsed = ffmpegCommand,                        AppliedFilters = filterStack as IList<MediaFilter> ?? new List<MediaFilter>(filterStack)                    ;                                // Get the file information                var fileInfo = new FileInfo(destinationPath);                if (!fileInfo.Exists)                                    throw new System.Exception($"Output file was not created: destinationPath");                                // Get media duration using FFmpeg probe                double durationSeconds = await GetMediaDurationAsync(destinationPath, cancellationToken);                return new EnhancementResult                                    IsSuccess = true,                    OutputFilePath = destinationPath,                    DurationSeconds = durationSeconds,                    FileSizeBytes = fileInfo.Length,                    ProcessingTime = stopwatch.Elapsed,                    CommandUsed = ffmpegCommand,                    AppliedFilters = filterStack as IList<MediaFilter> ?? new List<MediaFilter>(filterStack)                ;                        catch (OperationCanceledException)                            _logger.LogWarning("Enhancement operation was cancelled for SourcePath", sourcePath);                throw;                        catch (Exception ex)                            _logger.LogError(ex, "Error applying filters to SourcePath", sourcePath);                return new EnhancementResult                                    IsSuccess = false,                    OutputFilePath = destinationPath,                    ProcessingTime = TimeSpan.Zero,                    ErrorMessage = ex.Message,                    CommandUsed = "Command generation failed",                    AppliedFilters = filterStack as IList<MediaFilter> ?? new List<MediaFilter>(filterStack)                ;                            /// <inheritdoc />         async Task<string> GeneratePreviewThumbnailAsync(            string sourcePath,            double timePosition,            IEnumerable<MediaFilter> filterStack,            CancellationToken cancellationToken = default)                    if (_isDisposed)                throw new ObjectDisposedException(nameof(EnhancementEngine));            if (string.IsNullOrEmpty(sourcePath))                throw new System.Exception("Source path cannot be null or empty");            if (timePosition < 0)                throw new System.Exception("Time position must be non-negative");            if (!File.Exists(sourcePath))                throw new System.Exception($"Source file not found: sourcePath");            try                            _logger.LogInformation("Generating preview thumbnail for SourcePath at TimePositions",                    sourcePath, timePosition);                // Create temporary directory for output                string outputDir = Path.Combine(Path.GetTempPath(), "MediaEnhancementThumbnails");                Directory.CreateDirectory(outputDir);                // Generate output filename                string thumbnailFilename = $"preview_Path.GetFileNameWithoutExtension(sourcePath)_timePosition_Guid.NewGuid():N.jpg";                string outputPath = Path.Combine(outputDir, thumbnailFilename);                // Build FFmpeg command for thumbnail with filters                string ffmpegCommand = BuildThumbnailCommand(sourcePath, outputPath, timePosition, filterStack);                // Execute FFmpeg command                using var process = new Process                                    StartInfo = new ProcessStartInfo                                            FileName = "ffmpeg",                        Arguments = ffmpegCommand,                        UseShellExecute = false,                        CreateNoWindow = true,                        RedirectStandardError = true                                    ;                process.Start();                await process.WaitForExitAsync(cancellationToken);                if (process.ExitCode != 0)                                    string errorOutput = await process.StandardError.ReadToEndAsync(cancellationToken);                    _logger.LogError("FFmpeg process failed with exit code ExitCode: Error",                        process.ExitCode, errorOutput);                    throw new System.Exception($"Failed to generate thumbnail: errorOutput");                                // Verify the thumbnail was created                if (!File.Exists(outputPath))                                    throw new System.Exception($"Thumbnail file was not created: outputPath");                                _logger.LogInformation("Generated preview thumbnail at OutputPath", outputPath);                return outputPath;                        catch (OperationCanceledException)                            _logger.LogWarning("Thumbnail generation was cancelled for SourcePath", sourcePath);                throw;                        catch (Exception ex)                            _logger.LogError(ex, "Error generating preview thumbnail for SourcePath", sourcePath);                throw;                            /// <inheritdoc />         async Task<(string original, string enhanced)> GenerateComparisonPreviewsAsync(            string sourcePath,            double timePosition,            IEnumerable<MediaFilter> filterStack,            CancellationToken cancellationToken = default)                    if (_isDisposed)                throw new ObjectDisposedException(nameof(EnhancementEngine));            if (string.IsNullOrEmpty(sourcePath))                throw new System.Exception("Source path cannot be null or empty");            if (timePosition < 0)                throw new System.Exception("Time position must be non-negative");            if (!File.Exists(sourcePath))                throw new System.Exception($"Source file not found: sourcePath");            string originalPath = string.Empty;            string enhancedPath = string.Empty;            try                            _logger.LogInformation("Generating comparison previews for SourcePath at TimePositions",                    sourcePath, timePosition);                // Create temporary directory for output                string outputDir = Path.Combine(Path.GetTempPath(), "MediaEnhancementComparisons");                Directory.CreateDirectory(outputDir);                // Generate output filenames                string filePrefix = Path.GetFileNameWithoutExtension(sourcePath);                string originalFilename = $"original_filePrefix_timePosition_Guid.NewGuid():N.jpg";                string enhancedFilename = $"enhanced_filePrefix_timePosition_Guid.NewGuid():N.jpg";                originalPath = Path.Combine(outputDir, originalFilename);                enhancedPath = Path.Combine(outputDir, enhancedFilename);                // --- Extract original frame ---                 using (var processOriginal = new Process                                    StartInfo = new ProcessStartInfo                                            FileName = "ffmpeg",                        Arguments = $"-y -ss timePosition -i \"sourcePath\" -frames:v 1 -q:v 2 \"originalPath\"",                        UseShellExecute = false,                        CreateNoWindow = true,                        RedirectStandardError = true                                    )                                    processOriginal.Start();                    await processOriginal.WaitForExitAsync(cancellationToken);                    if (processOriginal.ExitCode != 0)                                            string errorOutput = await processOriginal.StandardError.ReadToEndAsync(cancellationToken);                        throw new FFmpegProcessingException($"Failed to extract original frame: errorOutput");                                        if (!File.Exists(originalPath))                                             throw new System.Exception($"Original preview file was not created: originalPath");                                        _logger.LogInformation("Generated original preview at OriginalPath", originalPath);                                // --- Extract enhanced frame ---                 string ffmpegCommandEnhanced = BuildThumbnailCommand(sourcePath, enhancedPath, timePosition, filterStack);                using (var processEnhanced = new Process                                    StartInfo = new ProcessStartInfo                                            FileName = "ffmpeg",                        Arguments = ffmpegCommandEnhanced,                        UseShellExecute = false,                        CreateNoWindow = true,                        RedirectStandardError = true                                    )                                    processEnhanced.Start();                    await processEnhanced.WaitForExitAsync(cancellationToken);                    if (processEnhanced.ExitCode != 0)                                            string errorOutput = await processEnhanced.StandardError.ReadToEndAsync(cancellationToken);                        throw new FFmpegProcessingException($"Failed to extract enhanced frame: errorOutput");                                        if (!File.Exists(enhancedPath))                                             throw new System.Exception($"Enhanced preview file was not created: enhancedPath");                                         _logger.LogInformation("Generated enhanced preview at EnhancedPath", enhancedPath);                                // Return paths to both previews                return (originalPath, enhancedPath);                        catch (OperationCanceledException)                            _logger.LogWarning("Comparison preview generation was cancelled for SourcePath", sourcePath);                // Clean up potentially created files on cancellation                if (File.Exists(originalPath)) File.Delete(originalPath);                if (File.Exists(enhancedPath)) File.Delete(enhancedPath);                throw;                        catch (Exception ex)                             _logger.LogError(ex, "Error generating comparison previews for SourcePath", sourcePath);                 // Clean up potentially created files on error                 if (File.Exists(originalPath)) File.Delete(originalPath);                 if (File.Exists(enhancedPath)) File.Delete(enhancedPath);                 throw new FFmpegProcessingException($"Error generating comparison previews: ex.Message", ex);                 // Ensure this method adheres to the return type Task<(string, string)>                 // If throwing, no return needed. If not throwing, must return a tuple.                 // Example (if not throwing): return (string.Empty, string.Empty);                        // Method MUST return a value or throw an exception before this point.            // Adding a throw here to satisfy compiler if the catch block doesn't rethrow or return.            // This line should ideally not be reached.            // throw new InvalidOperationException("GenerateComparisonPreviewsAsync reached end without returning a value or throwing.");                 async Task StopProcessingAsync(CancellationToken cancellationToken = default)                    if (_isDisposed)                throw new ObjectDisposedException(nameof(EnhancementEngine));            if (!_isActive)                return;            try                            await _ffmpegService.StopStreamProcessingAsync(cancellationToken);                _isActive = false;                _monitoringCts.Cancel();                if (_monitoringTask != null)                    await _monitoringTask;                _logger.LogInformation("Enhancement processing stopped");                        catch (Exception ex)                            _logger.LogError(ex, "Failed to stop enhancement processing");                throw;                             Task UpdateAudioFiltersAsync(AudioFilterChain audioFilters)                    if (_isDisposed)                throw new ObjectDisposedException(nameof(EnhancementEngine));            try                            _ffmpegService.UpdateAudioFilters(audioFilters);                _logger.LogInformation("Audio filters updated");                return Task.CompletedTask;                        catch (Exception ex)                            _logger.LogError(ex, "Failed to update audio filters");                throw;                             Task UpdateVideoFiltersAsync(VideoFilterChain videoFilters)                    if (_isDisposed)                throw new ObjectDisposedException(nameof(EnhancementEngine));            try                            _ffmpegService.UpdateVideoFilters(videoFilters);                _logger.LogInformation("Video filters updated");                return Task.CompletedTask;                        catch (Exception ex)                            _logger.LogError(ex, "Failed to update video filters");                throw;                             async Task<EnhancementStats> GetStatisticsAsync()                    if (_isDisposed)                throw new ObjectDisposedException(nameof(EnhancementEngine));            try                            var latency = await _ffmpegService.GetCurrentLatencyAsync();                var process = Process.GetCurrentProcess();                var stats = new EnhancementStats                                    CurrentLatency = latency,                    ProcessedFrames = _ffmpegService.ProcessedFrames,                    DroppedFrames = _ffmpegService.DroppedFrames,                    CpuUsage = process.TotalProcessorTime.TotalMilliseconds / process.UserProcessorTime.TotalMilliseconds * 100,                    MemoryUsage = process.WorkingSet64,                    WaveformData = Array.Empty<double>(), // Implement waveform visualization if enabled                    FilterMetrics = new Dictionary<string, double>()                ;                return stats;                        catch (Exception ex)                            _logger.LogError(ex, "Failed to get enhancement statistics");                throw;                             async Task MonitorStatisticsAsync(CancellationToken cancellationToken)                    try                            while (!cancellationToken.IsCancellationRequested)                                    var stats = await GetStatisticsAsync();                    CurrentLatency = stats.CurrentLatency;                    if (CurrentLatency > MaxLatency)                                            LatencyExceeded?.Invoke(this, CurrentLatency);                        _logger.LogWarning("Latency exceeded threshold: CurrentLatencyms > MaxLatencyms", CurrentLatency, MaxLatency);                                        StatisticsUpdated?.Invoke(this, stats);                    await Task.Delay(1000, cancellationToken); // Update every second                                        catch (OperationCanceledException)                            // Expected when stopping                        catch (Exception ex)                            _logger.LogError(ex, "Error in statistics monitoring task");                             async ValueTask DisposeAsync()                    if (_isDisposed)                return;            try                            _isDisposed = true;                if (_isActive)                    await StopProcessingAsync();                _monitoringCts?.Cancel();                _monitoringCts?.Dispose();                if (_ffmpegService is IAsyncDisposable disposable)                    await disposable.DisposeAsync();                        catch (Exception ex)                            _logger.LogError(ex, "Error during enhancement engine disposal");                             string BuildFilterCommand(string sourcePath, string destinationPath, IEnumerable<MediaFilter> filterStack)                    // Convert filter stack to FFmpeg filter chains            var videoFilters = new List<string>();            var audioFilters = new List<string>();            foreach (var filter in filterStack)                            if (!filter.IsEnabled)                    continue;                // Map filter to appropriate FFmpeg filter string                string filterString = MapFilterToFFmpegFilter(filter);                if (string.IsNullOrEmpty(filterString))                    continue;                // Determine if it's an audio or video filter                if (IsAudioFilter(filter.FilterId))                                    audioFilters.Add(filterString);                                else                                    videoFilters.Add(filterString);                                        // Construct filter chain arguments            string videoFilterArg = videoFilters.Count > 0 ? $"-vf \"string.Join(',', videoFilters)\"" : "";            string audioFilterArg = audioFilters.Count > 0 ? $"-af \"string.Join(',', audioFilters)\"" : "";            // Build the complete FFmpeg command            return $"-y -i \"sourcePath\" videoFilterArg audioFilterArg -c:v libx264 -preset fast -crf 23 -c:a aac -b:a 128k \"destinationPath\"";                 string BuildThumbnailCommand(string sourcePath, string outputPath, double timePosition, IEnumerable<MediaFilter> filterStack)                    // Convert filter stack to FFmpeg video filters            var videoFilters = new List<string>();            foreach (var filter in filterStack)                            if (!filter.IsEnabled || IsAudioFilter(filter.FilterId))                    continue;                // Map filter to appropriate FFmpeg filter string                string filterString = MapFilterToFFmpegFilter(filter);                if (string.IsNullOrEmpty(filterString))                    continue;                videoFilters.Add(filterString);                        // Construct filter chain argument            string videoFilterArg = videoFilters.Count > 0 ? $"-vf \"string.Join(',', videoFilters)\"" : "";            // Build the complete FFmpeg command for thumbnail extraction            return $"-y -ss timePosition -i \"sourcePath\" videoFilterArg -frames:v 1 -q:v 2 \"outputPath\"";                 bool TryParseProgress(string line, out EnhancementProgress progressInfo)                    progressInfo = new EnhancementProgress                            PercentComplete = 0,                CurrentOperation = "Processing",                TimeElapsed = TimeSpan.Zero            ;            if (string.IsNullOrEmpty(line))                return false;            // Example line: "frame=  592 fps= 59 q=29.0 size=    2048kB time=00:00:19.70 bitrate= 851.3kbits/s speed=1.97x"            if (line.Contains("time=") && line.Contains("speed="))                            // Parse time                int timeIndex = line.IndexOf("time=");                if (timeIndex >= 0)                                    string timeStr = line.Substring(timeIndex + 5, 11); // Format: 00:00:00.00                    if (TimeSpan.TryParse(timeStr, out var elapsed))                                            progressInfo.TimeElapsed = elapsed;                        // If we know the total duration, calculate percentage                        if (_mediaInfo != null && _mediaInfo.Duration > TimeSpan.Zero)                                                    double percent = Math.Min(100, (elapsed.TotalSeconds / _mediaInfo.Duration.TotalSeconds) * 100);                            progressInfo.PercentComplete = (int)percent;                            // Calculate estimated time remaining                            if (percent > 0)                                                            double totalSeconds = elapsed.TotalSeconds / (percent / 100);                                double remainingSeconds = totalSeconds - elapsed.TotalSeconds;                                progressInfo.EstimatedTimeRemaining = TimeSpan.FromSeconds(remainingSeconds);                                                                            return true;                                                            return false;                 bool IsAudioFilter(string filterId)                    // Determine if a filter is an audio filter based on its ID or category            return filterId.StartsWith("audio_") ||                   filterId.StartsWith("eq_") ||                   filterId.StartsWith("volume_") ||                   filterId.StartsWith("pitch_") ||                   filterId.StartsWith("noise_reduction_audio");                 string MapFilterToFFmpegFilter(MediaFilter filter)                    // Map filter to corresponding FFmpeg filter syntax            switch (filter.FilterId)                            // Video filters                case "sharpness": return $"unsharp=5:5:filter.Value / 10.0";                case "brightness": return $"eq=brightness=(filter.Value - 50) / 50.0";                case "contrast": return $"eq=contrast=(filter.Value / 50.0)";                case "saturation": return $"eq=saturation=(filter.Value / 50.0)";                case "hue": return $"hue=h=(filter.Value - 50) * 3.6";                case "noise_reduction_video": return $"nlmeans=h=filter.Value / 10.0";                // Audio filters                case "volume": return $"volume=(filter.Value / 50.0)";                case "bass": return $"equalizer=f=100:t=q:w=1:g=(filter.Value - 50) / 10.0";                case "treble": return $"equalizer=f=8000:t=q:w=1:g=(filter.Value - 50) / 10.0";                case "noise_reduction_audio": return $"afftdn=nf=filter.Value / 10.0";                // Default case for unknown filters                default: return "";                             async Task<double> GetMediaDurationAsync(string filePath, CancellationToken cancellationToken)                    try                            // Use FFprobe to get media duration                using var process = new Process                                    StartInfo = new ProcessStartInfo                                            FileName = "ffprobe",                        Arguments = $"-v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 \"filePath\"",                        UseShellExecute = false,                        RedirectStandardOutput = true,                        CreateNoWindow = true                                    ;                process.Start();                string output = await process.StandardOutput.ReadToEndAsync(cancellationToken);                await process.WaitForExitAsync(cancellationToken);                if (process.ExitCode == 0 && double.TryParse(output.Trim(), out double duration))                                    return duration;                                return 0;                        catch (Exception ex)                            _logger.LogError(ex, "Error getting media duration for FilePath", filePath);                return 0;                             async Task ReadErrorOutputAsync(StreamReader errorReader, IProgress<string> progressHandler, CancellationToken cancellationToken)                    while (!errorReader.EndOfStream)                            var line = await errorReader.ReadLineAsync();                if (line != null)                                    progressHandler.Report(line);                                            // Implement IEnhancementEngine members         IEnumerable<FilterCategory> GetFilterCategories()                    return Enum.GetValues<FilterCategory>();                 IEnumerable<FilterDefinition> GetAvailableFilters(FilterCategory category)                    // Return available filters for the given category            return new List<FilterDefinition>();                 Task<bool> InitializeAsync(EnhancementConfig config, CancellationToken cancellationToken = default)                    _config = config ?? throw new ArgumentNullException(nameof(config));            return Task.FromResult(true);                 async Task StartProcessingAsync(string inputUrl, string outputUrl, CancellationToken cancellationToken = default)                    if (_isDisposed)                throw new ObjectDisposedException(nameof(EnhancementEngine));            if (_isActive)                throw new InvalidOperationException("Enhancement processing is already active");            if (_config == null)                throw new InvalidOperationException("Engine not initialized. Call InitializeAsync first.");            try                            // Initialize real-time service                await _ffmpegService.InitializeAsync(inputUrl, HardwareAccelerationMode.Auto, cancellationToken);                _isActive = true;                _monitoringCts = new CancellationTokenSource();                // Start monitoring task                _monitoringTask = MonitorStatisticsAsync(_monitoringCts.Token);                _logger.LogInformation("Enhancement processing started. Input: InputUrl, Output: OutputUrl", inputUrl, outputUrl);                        catch (Exception ex)                            _logger.LogError(ex, "Failed to start enhancement processing");                throw;                        